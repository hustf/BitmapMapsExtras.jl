# Drawing functionality,
# builds on `draw_direct.jl` and `BitmapMaps.jl/mark_utils.jl`.
# Tied in with how we define a matrix format for bidirectional quantity 
# pairs in `differential_geom/curvature.jl`
# Contains `plot_principal_directions_glyph!` and `draw_bidirectional_quantity_glyph!` 
# and callee `draw_two_arrow_glyph!`

"""
    plot_principal_directions_glyph!(cov, pt, directions, f_is_within_limits, dashsize, K, strength)

This checks if the glyph is within limits. That function argument is generated by e.g. `allocations_curvature`.

Also see `draw_bidirectional_quantity_glyph!`
"""
function plot_principal_directions_glyph!(cov, pt, directions, f_is_within_limits, dashsize, K, strength)
    # Extract primary and / or secondary principal components
    dK =  K[:, directions]
    if f_is_within_limits(dK)
        draw_bidirectional_quantity_glyph!(cov, pt, dK, strength)
    else
        # A dash instead of the out-of-limits curvature glyph
        if dashsize > 0
            spray!(cov, pt, Float32(dashsize), strength)
        end
    end
    cov
end






"""
    draw_bidirectional_quantity_glyph!(cov, p, K, strength)
    draw_bidirectional_quantity_glyph!(cov, p, v::AbstractVector, strength)

Draws two-arrow glyphs on an image at position `p` for principal bi-directional quantities
specified by the matrix `K`.

# Arguments
- `cov`: The coverage matrix to render the glyphs onto.
- `p`: The location of the glyphs in 2D space.
- `K`: A principal bi-directional 4x4 matrix where `K[:,1]` specifies the first principal direction,
  magnitude, and sign, and `K[:,2]` specifies the second. See [`draw_two_arrow_glyph!`](@ref).
- `strength`: the maximum coverage applied to pixels

# Details
Due to symmetry, only 180° (π) is needed for the direction of each quantity. The additional
information is used to determine if the quantity is negative (arrows toward `p`) or positive
(arrows from `p`).

# Notes
- As an example, 2D principal stress directions are always orthonormal, whereas in `K`, the
  directions need not be orthonormal. If an orthonormal glyph is projected onto a plane that is
  rotated with respect to the stress plane, the projected axes would not be orthonormal. This
  function could be used to draw such a projection.
- This function modifies `img` in-place.

# Examples
```julia
img = zeros(100, 100)  # Example image matrix
p = [50.0, 50.0]       # Center position
K = rand(4, 4)         # Example principal bi-directional matrix
draw_bidirectional_quantity_glyph!(img, p, K)  # Draws two glyphs
```
"""
function draw_bidirectional_quantity_glyph!(cov, p, K, strength)
    @assert size(K) == (2, 2)
    draw_two_arrow_glyph!(cov, p, view(K, :, 1), strength)
    draw_two_arrow_glyph!(cov, p, view(K, :, 2), strength)
end
function draw_bidirectional_quantity_glyph!(cov, p, v::AbstractVector, strength)
    @assert size(v, 1) == 2
    draw_two_arrow_glyph!(cov, p, v, strength)
end

"""
    draw_two_arrow_glyph!(cov, p, v::AbstractVector, strength)

img is the image matrix
p is the location
F is the length of both arrows. If negative, arrows end at p.
v[1:2] specifies both direction and sign. 
    0-π:  Positive sign, arrows outward.   
    π-2π: Negative sign: arrows inward.   
"""
function draw_two_arrow_glyph!(cov, p, v::AbstractVector, strength)
    Δj = Int(round(v[1]))
    Δi = Int(round(v[2]))
    if is_bidirec_vect_positive(v)
        # First or second quadrant. Positive.
        draw_vector!(cov, p, -Δi, Δj, strength)
        draw_vector!(cov, p, Δi, -Δj, strength)
    else
        # Third or fourth quadrant. Negative.
        draw_vector!(cov, p + CartesianIndex(-Δi, Δj), Δi, -Δj, strength)
        draw_vector!(cov, p + CartesianIndex(Δi, -Δj), -Δi, Δj, strength)
    end
end


function func_is_glyph_within_limits(directions, maxg, ming)
    # Captures variables maxg (checked to be > 0) and ming (checked to be < 0)
    @assert maxg >= 0
    @assert ming < maxg
    if 1 ∈ directions && 2 ∈ directions
        # Checks a glyph for max and min principal directions. 
        # Input K is a (scaled) 4x4 matrix.
        f_is_within_limits = let maxg=maxg, ming=ming, minglyph_abs=abs(ming)
            @inline function(K)
                K1 = @view K[:, 1]
                K2 = @view K[:, 2]
                limit1 = is_bidirec_vect_positive(K1) ? maxg : minglyph_abs
                limit2 = is_bidirec_vect_positive(K2) ? maxg : minglyph_abs
                norm(K1) ≤ limit1 || return false
                norm(K2) ≤ limit2 || return false
                return true
            end
        end
    elseif 2 ∈ directions || 1 ∈ directions
        # Checks a glyph for one principal direction. 
        # Input v is a vector
        f_is_within_limits = let maxg=maxg, ming=ming, minglyph_abs=abs(ming)
            @inline function(v)
                limit = is_bidirec_vect_positive(v) ? maxg : minglyph_abs
                norm(v) ≤ limit
            end
        end
    else
        # The callee maybe doesn't need a function, so we'll just hand over this cheap one.
        f_is_within_limits = identity
    end
    f_is_within_limits
end
